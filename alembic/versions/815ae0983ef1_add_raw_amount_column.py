"""Add raw_amount column

Revision ID: 815ae0983ef1
Revises: f0e8022dc814
Create Date: 2022-06-08 12:39:35.846110

"""
from alembic import op
import brownie
import sqlalchemy as sa
from brownie import network, Contract
from typing import List, Dict, Optional, Any

# from ..engineapi.Dropper import Dropper


# revision identifiers, used by Alembic.
revision = "815ae0983ef1"
down_revision = "f0e8022dc814"
branch_labels = None
depends_on = None


BLOCKCHAINS_TO_BROWNIE_NETWORKS: Dict[str, str] = {
    "polygon": "moonstream-engine-polygon",
    "mumbai": "mumbai",
}

abi_token_type = [
    {
        "inputs": [{"internalType": "uint256", "name": "claimId", "type": "uint256"}],
        "name": "getClaim",
        "outputs": [
            {
                "components": [
                    {"internalType": "uint256", "name": "tokenType", "type": "uint256"},
                    {
                        "internalType": "address",
                        "name": "tokenAddress",
                        "type": "address",
                    },
                    {"internalType": "uint256", "name": "tokenId", "type": "uint256"},
                    {"internalType": "uint256", "name": "amount", "type": "uint256"},
                ],
                "internalType": "struct Dropper.ClaimableToken",
                "name": "",
                "type": "tuple",
            }
        ],
        "stateMutability": "view",
        "type": "function",
    }
]

abi_erc20_zeros = [
    {
        "inputs": [],
        "name": "decimals",
        "outputs": [{"internalType": "uint8", "name": "", "type": "uint8"}],
        "stateMutability": "view",
        "type": "function",
    }
]


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column(
        "dropper_claimants", sa.Column("raw_amount", sa.String(), nullable=True)
    )

    # sync raw_amount column with amount column

    # create chache of claim token type
    # newtwork contract and list of claims with their token type

    token_tytes: Dict[str, Dict[str, List[Dict[str, Any]]]] = dict()

    conn = op.get_bind()
    res = conn.execute(
        """select distinct dropper_contracts.blockchain, dropper_contracts.address, dropper_claims.claim_id from dropper_contracts 
                        left join dropper_claims on dropper_contracts.id = dropper_claims.dropper_contract_id
                        where dropper_claims.claim_id is not null"""
    )
    results = res.fetchall()

    for blockchain, address, claim_id in results:
        if blockchain not in token_tytes:
            token_tytes[blockchain] = dict()
        if address not in token_tytes[blockchain]:
            token_tytes[blockchain][address] = list()
        token_tytes[blockchain][address].append(claim_id)

    conn.execute(
        """
        create table temptest
        (
            blockchain varchar, 
            address varchar, 
            claim_id varchar,
            token_type varchar,
            zeros varchar
        )
            
        """
    )

    for blockchain in token_tytes:
        brownie_network = BLOCKCHAINS_TO_BROWNIE_NETWORKS.get(blockchain)
        network.connect(brownie_network)
        for address in token_tytes[blockchain]:
            dropper_contract: Optional[Contract] = Contract.from_abi(
                "Dropper", address, abi_token_type
            )
            for claim_id in token_tytes[blockchain][address]:
                claim_info = dropper_contract.getClaim(claim_id)
                zeros = None
                if claim_info[0] == 20:
                    erc20_contract: Optional[Contract] = Contract.from_abi(
                        "erc20", claim_info[1], abi_erc20_zeros
                    )
                    zeros = "0" * erc20_contract.decimals()
                conn.execute(
                    """
                            insert into temptest
                            (
                                blockchain, 
                                address, 
                                claim_id,
                                token_type,
                                zeros

                            )
                            values
                            (
                                %s, 
                                %s, 
                                %s,
                                %s,
                                %s
                            )
                            """,
                    (blockchain, address, claim_id, str(claim_info[0]), zeros),
                )

        network.disconnect()

    # update raw_amount column
    conn.execute(
        """
        update dropper_claimants
        set raw_amount = (CASE
                           WHEN (select temptest.token_type from temptest inner join dropper_claims ON temptest.claim_id::int = dropper_claims.claim_id where dropper_claims.id = dropper_claimants.dropper_claim_id)::int = 20
                             THEN CONCAT(CAST(dropper_claimants.amount as varchar), (select temptest.zeros from temptest inner join dropper_claims ON temptest.claim_id::int = dropper_claims.claim_id where dropper_claims.id = dropper_claimants.dropper_claim_id))
                           WHEN true
                             THEN CAST(dropper_claimants.amount as varchar)
                           END);
        """
    )


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_column("dropper_claimants", "raw_amount")
    op.drop_table("temptest")
    # ### end Alembic commands ###
